const API_URL = "Your API Endpoint";
const API_KEY = "Your API Key"

const FONT_SCALE = 0.3;
const SMOOTHING_RATIO = 0.2;
const REFRESH_MINUTES = 10;
const CACHE_FILE = "token_history_braun_final_key.json";

const THEME = {
  bg: Color.dynamic(new Color("#f4f4f4"), new Color("#161616")),
  title: Color.dynamic(new Color("#888888"), new Color("#888888")), 
};

const CHART_PALETTE = {
  active: new Color("#ea5b0c"), 
  grid: new Color("#888888", 0.15),
  axis: new Color("#8e8e93"), 
  
  dotFill: new Color("#e5e5e5"), 

  capsuleBgCommon: new Color("#888888", 0.15),
  capsuleTextCommon: new Color("#8e8e93"),
  capsuleBgHighlight: new Color("#ea5b0c"),
  capsuleTextHighlight: new Color("#ffffff")
};

if (config.runsInWidget) {
  const widget = await createWidget();
  Script.setWidget(widget);
} else {
  const widget = await createWidget();
  widget.presentMedium();
}
Script.complete();

async function createWidget() {
  const w = new ListWidget();
  const family = config.widgetFamily || "medium";

  w.backgroundColor = THEME.bg; 
  w.backgroundImage = createStripes(family);
  w.setPadding(8, 10, 8, 10);
  w.refreshAfterDate = new Date(Date.now() + REFRESH_MINUTES * 60 * 1000);

  let chartData = await get7DayData();
  
  const hasRealData = chartData.some(d => d.val > 0);
  if (!hasRealData) {
      console.warn("⚠️ 提示: 当前显示为全0数据 (可能是获取失败)");
  }

  w.addSpacer(12);

  const header = w.addStack();
  header.layoutHorizontally();
  header.addSpacer();
  const title = header.addText("近 7 天 Token 使用趋势");
  title.font = Font.heavySystemFont(Math.round(36 * FONT_SCALE));
  title.textColor = THEME.title;
  header.addSpacer();

  w.addSpacer(20);

  const { chartW, chartH } = getChartDisplaySize(family);
  const chartImage = drawBraunWaveChart(chartData, chartW, chartH);

  if (chartImage) {
      const img = w.addImage(chartImage);
      img.imageSize = new Size(chartW, chartH);
      img.centerAlignImage();
  }

  w.addSpacer();
  return w;
}

async function get7DayData() {
  const fm = FileManager.local();
  const cachePath = fm.joinPath(fm.documentsDirectory(), CACHE_FILE);

  let history = [];

  try {
    const req = new Request(API_URL);
    req.headers = { 
        "X-N8N-API-KEY": API_KEY,
        "User-Agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        "Accept": "application/json",
        "Content-Type": "application/json"
    };
    req.timeoutInterval = 15; 
    
    const rawString = await req.loadString();
    
    if (rawString.includes("Authorization data is wrong")) {
        throw new Error("API Key 仍然被拒绝，请检查 N8N 设置");
    }

    const json = JSON.parse(rawString);

    let rawList = [];
    if (Array.isArray(json) && json.length > 0 && json[0]["history_7d"]) {
       rawList = json[0]["history_7d"];
    } else if (json && json["history_7d"]) {
       rawList = json["history_7d"];
    }

    if (Array.isArray(rawList)) {
        history = rawList.map(item => {
            const v = Number(item["val"]);
            let dStr = item["date"] || "";
            const parts = dStr.split("-");
            if (parts.length === 3) {
                dStr = `${parts[1]}-${parts[2]}`;
            }
            return { date: dStr, val: isNaN(v) ? 0 : v };
        });
    }

    history.sort((a, b) => (a.date > b.date ? 1 : -1));
    if (history.length > 7) history = history.slice(history.length - 7);

    if (history.length > 0) {
        fm.writeString(cachePath, JSON.stringify(history));
    } 

  } catch (e) {
    console.error("⛔️ Error: " + e.message);
    if (fm.fileExists(cachePath)) {
      try { history = JSON.parse(fm.readString(cachePath)); } catch (_) {}
    }
  }

  if (!history || history.length === 0) {
      return generateDemoData(); 
  }
  
  return history;
}

function generateDemoData() {
    const arr = [];
    const df = new DateFormatter();
    df.dateFormat = "MM-dd";
    const now = new Date();
    for (let i=6; i>=0; i--) {
        const d = new Date(now.getTime() - i*24*3600*1000);
        arr.push({ date: df.string(d), val: 0 }); 
    }
    return arr;
}

function drawBraunWaveChart(data, W, H) {
  const ctx = new DrawContext();
  ctx.size = new Size(W, H);
  ctx.opaque = false;
  ctx.respectScreenScale = true;

  if (!data || data.length === 0) return ctx.getImage();

  const SCALE = Device.screenScale();
  const px = (v) => Math.round(v * SCALE) / SCALE;
  const stepValue = 500000; 

  const margin = {
    top: Math.max(10, Math.round(H * 0.14)),
    bottom: Math.max(24, Math.round(H * 0.24)),
    left: Math.max(14, Math.round(W * 0.06)),
    right: Math.max(14, Math.round(W * 0.06))
  };

  const graphH = H - margin.top - margin.bottom;
  const graphW = W - margin.left - margin.right;

  const maxDataVal = Math.max(...data.map(d => d.val), 100);
  
  let maxScale = Math.ceil(maxDataVal / stepValue) * stepValue;
  if (maxScale < stepValue) maxScale = stepValue;
  let minScale = 0;

  const range = Math.max(stepValue, maxScale - minScale);
  const hairline = 1 / SCALE;

  for (let v = minScale; v <= maxScale; v += stepValue) {
    if (v === maxScale) continue; 
    const y = px(margin.top + graphH - ((v - minScale) / range) * graphH);
    
    const path = new Path();
    path.move(new Point(margin.left, y));
    path.addLine(new Point(W - margin.right, y));

    ctx.addPath(path);
    ctx.setLineWidth(hairline);
    ctx.setStrokeColor(v === 0 ? new Color("#888888", 0.4) : CHART_PALETTE.grid);
    ctx.strokePath();
  }

  const points = [];
  if (data.length === 1) {
    points.push({
      x: px(W / 2),
      y: px(margin.top + graphH - ((data[0].val - minScale) / range) * graphH),
      val: data[0].val,
      date: data[0].date
    });
  } else {
    const stepX = graphW / (data.length - 1);
    for (let i = 0; i < data.length; i++) {
      const item = data[i];
      const x = px(margin.left + i * stepX);
      const y = px(margin.top + graphH - ((item.val - minScale) / range) * graphH);
      points.push({ x, y, val: item.val, date: item.date });
    }
  }

  if (points.length > 1) {
    const pathLine = new Path();
    pathLine.move(new Point(points[0].x, points[0].y));

    for (let i = 0; i < points.length - 1; i++) {
      const pStart = points[i];
      const pEnd = points[i + 1];
      const pPrev = i > 0 ? points[i - 1] : points[i];
      const pNext = i < points.length - 2 ? points[i + 2] : points[i + 1];

      let cp1 = getControlPoint(pPrev, pStart, pEnd, false, SMOOTHING_RATIO);
      let cp2 = getControlPoint(pStart, pEnd, pNext, true, SMOOTHING_RATIO);
      
      if (i === 0) {
          cp1 = { x: pStart.x + (pEnd.x - pStart.x) * 0.2, y: pStart.y + (pEnd.y - pStart.y) * 0.2 };
      }

      cp1.x = px(cp1.x); cp1.y = px(cp1.y);
      cp2.x = px(cp2.x); cp2.y = px(cp2.y);

      pathLine.addCurve(new Point(pEnd.x, pEnd.y), new Point(cp1.x, cp1.y), new Point(cp2.x, cp2.y));
    }
    
    ctx.setStrokeColor(CHART_PALETTE.active);
    ctx.setLineWidth(3);
    ctx.addPath(pathLine);
    ctx.strokePath();
  }

  const dotSize = Math.max(5, Math.round(H * 0.055));
  
  for (let index = 0; index < points.length; index++) {
    const p = points[index];
    const isToday = index === points.length - 1;

    const dotRect = new Rect(px(p.x - dotSize / 2), px(p.y - dotSize / 2), dotSize, dotSize);
    
    ctx.setFillColor(CHART_PALETTE.dotFill);
    ctx.fillEllipse(dotRect);

    const strokePath = new Path();
    strokePath.addEllipse(dotRect);
    ctx.addPath(strokePath);
    ctx.setStrokeColor(CHART_PALETTE.active);
    ctx.setLineWidth(2);
    ctx.strokePath();

    const dateFontSize = Math.max(9, Math.round(H * 0.10 * FONT_SCALE));
    ctx.setFont(Font.boldSystemFont(dateFontSize));
    ctx.setTextColor(CHART_PALETTE.axis);
    ctx.setTextAlignedCenter();
    const dateRect = new Rect(px(p.x - 28), px(H - margin.bottom + 2), 56, margin.bottom - 4);
    ctx.drawTextInRect(p.date, dateRect);

    const valStr = formatCompact(p.val);
    const fontSize = isToday ? Math.max(11, Math.round(H * 0.13 * FONT_SCALE)) : Math.max(10, Math.round(H * 0.11 * FONT_SCALE));
    const font = isToday ? Font.heavySystemFont(fontSize) : Font.boldSystemFont(fontSize);
    
    ctx.setFont(font);
    const charW = fontSize * 0.6;
    let textWidth = px(valStr.length * charW + 10);
    const tagH = isToday ? 16 : 14;
    
    let tagX = px(p.x - textWidth / 2);
    let tagY = px(p.y - tagH - Math.round(H * 0.08));

    if (tagX + textWidth > W) tagX = W - textWidth;
    if (tagX < 0) tagX = 0;
    if (tagY < 2) tagY = 2;

    const bgRect = new Rect(tagX, tagY, textWidth, tagH);
    const cornerRadius = tagH * 0.35;
    
    ctx.setFillColor(isToday ? CHART_PALETTE.capsuleBgHighlight : CHART_PALETTE.capsuleBgCommon);
    const tagPath = new Path();
    tagPath.addRoundedRect(bgRect, cornerRadius, cornerRadius);
    ctx.addPath(tagPath);
    ctx.fillPath();

    ctx.setTextAlignedCenter();
    ctx.setTextColor(isToday ? CHART_PALETTE.capsuleTextHighlight : CHART_PALETTE.capsuleTextCommon);
    const textRect = new Rect(tagX, px(tagY + 1), textWidth, tagH);
    ctx.drawTextInRect(valStr, textRect);
  }

  return ctx.getImage();
}

function getControlPoint(pPrev, pCurr, pNext, isEnd, smoothing) {
  const lengthX = pNext.x - pPrev.x;
  const lengthY = pNext.y - pPrev.y;
  const length = Math.sqrt(lengthX * lengthX + lengthY * lengthY) * smoothing;
  const angle = Math.atan2(lengthY, lengthX) + (isEnd ? Math.PI : 0);
  return { x: pCurr.x + Math.cos(angle) * length, y: pCurr.y + Math.sin(angle) * length };
}

function createStripes(widgetFamily) {
  const scale = Device.screenScale();
  const px = (v) => Math.round(v * scale) / scale;
  
  let wPt = 320;
  let hPt = 160;

  if (widgetFamily === "small") { 
    wPt = 160; 
    hPt = 160; 
  } else if (widgetFamily === "large") { 
    wPt = 320; 
    hPt = 340; 
  } else if (widgetFamily === "extraLarge") { 
    wPt = 520; 
    hPt = 260; 
  }

  const ctx = new DrawContext();
  ctx.size = new Size(wPt, hPt);
  ctx.opaque = false;
  ctx.respectScreenScale = true;

  const stripeColor = new Color("#888888", 0.04);
  const lineWidth = 2 / scale;
  const gap = 10 / scale;

  ctx.setFillColor(stripeColor);
  for (let x = 0; x < ctx.size.width; x += gap) {
    ctx.fillRect(new Rect(px(x), 0, lineWidth, ctx.size.height));
  }
  return ctx.getImage();
}

function getChartDisplaySize(widgetFamily) {
  switch (widgetFamily) {
    case "small": return { chartW: 150, chartH: 115 };
    case "large": return { chartW: 330, chartH: 220 };
    case "extraLarge": return { chartW: 500, chartH: 260 };
    case "medium": default: return { chartW: 320, chartH: 118 };
  }
}

function formatCompact(num) {
  const m = num / 1000000;
  let s = m.toFixed(1).replace(/\.0$/, "");
  return s + "M";
}
