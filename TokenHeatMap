const API_URL = "Your API Endpoint";
const API_KEY = "Your API Key";

const FORCE_APPEARANCE = null; // "light" or "dark" or null
const CACHE_TTL_MS = 60 * 60 * 1000;
const REFRESH_MINUTES = 10;
const CACHE_FILE_NAME = "token_heatmap_v3_auto_range.json";

const THEME = {
  bg: { light: "#ffffff", dark: "#0d1117" },
  text: { light: "#24292f", dark: "#c9d1d9" },
  subtleText: { light: "#57606a", dark: "#8b949e" },
  todayStroke: { light: "#000000", dark: "#ffffff" },
  stripes: { light: 0.04, dark: 0.035 },
  cells: {
    future: { light: "#ebedf0", dark: "#161b22" },
    level0: { light: "#ebedf0", dark: "#161b22" },
    level1: { light: "#9be9a8", dark: "#0e4429" },
    level2: { light: "#30a14e", dark: "#006d32" },
    level3: { light: "#216e39", dark: "#26a641" }
  }
};

const LAYOUT = {
  weeks: 26, 
  boxSize: 16,
  gap: 4,
  startX: 10,
  startY: 30,
  widthPad: 20,
  height: 220
};

const dyn = (l, d) => Color.dynamic(new Color(l), new Color(d));

const UI = (() => {
  const forced =
    FORCE_APPEARANCE === "dark" ? "dark" :
    FORCE_APPEARANCE === "light" ? "light" : null;

  const c = (obj) => forced
    ? new Color(obj[forced])
    : dyn(obj.light, obj.dark);

  const cell = (k) => forced
    ? new Color(THEME.cells[k][forced])
    : dyn(THEME.cells[k].light, THEME.cells[k].dark);

  const alpha = forced
    ? THEME.stripes[forced]
    : null;

  return {
    forced,
    bg: c(THEME.bg),
    text: c(THEME.text),
    subtleText: c(THEME.subtleText),
    todayStroke: c(THEME.todayStroke),
    cell,
    stripesColor: forced
      ? new Color("#888888", alpha)
      : Color.dynamic(
          new Color("#888888", THEME.stripes.light),
          new Color("#888888", THEME.stripes.dark)
        )
  };
})();

if (config.runsInWidget) {
  const widget = await createWidget();
  Script.setWidget(widget);
} else {
  const widget = await createWidget();
  widget.presentMedium();
}
Script.complete();

async function createWidget() {
  const w = new ListWidget();
  w.backgroundColor = UI.bg;
  w.backgroundImage = createTransparentStripes();
  w.setPadding(12, 18, 12, 12);
  w.refreshAfterDate = new Date(Date.now() + REFRESH_MINUTES * 60 * 1000);

  const header = w.addStack();
  header.layoutHorizontally();
  header.centerAlignContent();

  const title = header.addText("Token 使用分布");
  title.font = Font.heavySystemFont(12);
  title.textColor = UI.text;

  header.addSpacer();
  w.addSpacer(8);

  const dataMap = await getHistoryData();
  const chartImage = drawSixMonthHeatmap(dataMap);
  const img = w.addImage(chartImage);
  img.applyFittingContentMode();
  img.centerAlignImage();

  return w;
}

function drawSixMonthHeatmap(dataMap) {
  const { weeks, boxSize, gap, startX, startY, widthPad, height } = LAYOUT;
  const W = startX + weeks * (boxSize + gap) + widthPad;
  const H = height;

  const ctx = new DrawContext();
  ctx.size = new Size(W, H);
  ctx.opaque = false;
  ctx.respectScreenScale = true;

  const SCALE = Device.screenScale();
  const px = (v) => Math.round(v * SCALE) / SCALE;

  const now = new Date();
  const todayKey = formatDateKey(now);

  const gridStartDate = startOfWeek(addDays(now, -((weeks - 1) * 7)));

  let lastLabelMonth = -1;
  let lastLabelX = -50;

  for (let col = 0; col < weeks; col++) {
    for (let row = 0; row < 7; row++) {
      const d = addDays(gridStartDate, col * 7 + row);
      const dateKey = formatDateKey(d);
      
      const val = dataMap[dateKey] || 0;

      const x = px(startX + col * (boxSize + gap));
      const y = px(startY + row * (boxSize + gap));
      const rect = new Rect(x, y, boxSize, boxSize);

      if (row === 0) {
        const m = d.getMonth();
        if (m !== lastLabelMonth && (x - lastLabelX > 25)) {
          ctx.setFont(Font.boldSystemFont(16));
          ctx.setTextColor(UI.subtleText);
          ctx.drawText(getMonthName(m), new Point(x, 5));
          lastLabelMonth = m;
          lastLabelX = x;
        }
      }

      const path = new Path();
      path.addRoundedRect(rect, 3, 3);
      ctx.addPath(path);

      const isFuture = dateKey > todayKey;
      if (isFuture) {
        ctx.setStrokeColor(UI.cell("future"));
        ctx.setLineWidth(1); // 稍微细一点
        ctx.strokePath();
        continue;
      }

      ctx.setFillColor(levelColor(val));
      ctx.fillPath();

      if (dateKey === todayKey) {
        ctx.setStrokeColor(new Color(UI.todayStroke.hex, 0.6));
        ctx.setLineWidth(3);
        ctx.strokePath();
      }
    }
  }

  drawInternalLegend(ctx, W, H);
  return ctx.getImage();
}

function levelColor(val) {
  if (val === 0) return UI.cell("level0");
  if (val < 500000) return UI.cell("level1");
  if (val < 1000000) return UI.cell("level2");
  return UI.cell("level3");
}

function drawInternalLegend(ctx, W, H) {
  const legendSize = 12;
  const legendGap = 4;
  const rightMargin = -10;
  const bottomMargin = 10;

  const items = [
    UI.cell("level0"),
    UI.cell("level1"),
    UI.cell("level2"),
    UI.cell("level3")
  ];

  const totalW = items.length * legendSize + (items.length - 1) * legendGap + 80;
  const startX = W - totalW - rightMargin;
  const startY = H - legendSize - bottomMargin;

  ctx.setFont(Font.heavySystemFont(12));
  ctx.setTextColor(UI.subtleText);
  ctx.drawText("轻度", new Point(startX, startY - 2));

  let x = startX + 35;
  for (const c of items) {
    const rect = new Rect(x, startY, legendSize, legendSize);
    ctx.setFillColor(c);
    const p = new Path();
    p.addRoundedRect(rect, 2, 2);
    ctx.addPath(p);
    ctx.fillPath();
    x += legendSize + legendGap;
  }

  ctx.drawText(" 重度", new Point(x + 2, startY - 2));
}

async function getHistoryData() {
  const fm = FileManager.local();
  const cachePath = fm.joinPath(fm.documentsDirectory(), CACHE_FILE_NAME);

  const readCache = () => {
    if (!fm.fileExists(cachePath)) return null;
    try { return JSON.parse(fm.readString(cachePath)); } catch { return null; }
  };

  const cache = readCache();
  const nowTs = Date.now();
  if (cache?.ts && cache?.data && (nowTs - cache.ts) < CACHE_TTL_MS) return cache.data;

  try {
    const req = new Request(API_URL);
    req.headers = { 
        "X-N8N-API-KEY": API_KEY,
        "User-Agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        "Accept": "application/json"
    };
    req.timeoutInterval = 15;

    console.log("Fetching full history...");
    const rawString = await req.loadString();
    
    if (rawString.includes("Authorization data is wrong")) {
        throw new Error("API Key 错误");
    }

    const json = JSON.parse(rawString);
    const root = Array.isArray(json) && json.length > 0 ? json[0] : json;

    let targetArray = [];
    
    const candidates = [
        root.history,
        root.history_all,
        root.history_365d,
        root.history_180d,
        root.history_90d,
        root.history_30d,
        root.history_7d,
        json
    ];

    for (const c of candidates) {
        if (Array.isArray(c) && c.length > targetArray.length) {
            targetArray = c;
        }
    }

    console.log(`Found best data source with ${targetArray.length} items.`);

    const map = {};
    for (const item of targetArray) {
      let d = item?.date || "";
      if (d.includes("/")) d = d.replace(/\//g, "-");
      
      const v = item?.val ?? item?.today ?? item?.tokens ?? 0;
      
      if (d && d.length >= 10) {
          map[d.substring(0, 10)] = (Number.parseInt(v, 10) || 0);
      }
    }

    const todayKey = formatDateKey(new Date());
    if (map[todayKey] === undefined) {
        let liveVal = root.today ?? 0;
        map[todayKey] = Number.parseInt(liveVal, 10) || 0;
    }

    if (Object.keys(map).length > 0) {
        fm.writeString(cachePath, JSON.stringify({ ts: nowTs, data: map }));
    }
    
    return map;
  } catch (e) {
    console.error("Fetch Error: " + e.message);
    return cache?.data || {};
  }
}

function createTransparentStripes() {
  const ctx = new DrawContext();
  const W = 600, H = 400;
  ctx.size = new Size(W, H);
  ctx.opaque = false;
  ctx.respectScreenScale = true;

  const SCALE = Device.screenScale();
  const px = (v) => Math.round(v * SCALE) / SCALE;

  const gap = 8;
  const lineW = 2;

  ctx.setFillColor(UI.stripesColor);
  for (let x = 0; x < W; x += gap) ctx.fillRect(new Rect(px(x), 0, lineW, H));
  return ctx.getImage();
}

function getMonthName(i) {
  return ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][i] || "";
}

function formatDateKey(date) {
  const y = date.getFullYear();
  const m = String(date.getMonth() + 1).padStart(2, "0");
  const d = String(date.getDate()).padStart(2, "0");
  return `${y}-${m}-${d}`;
}

function addDays(date, days) {
  const d = new Date(date);
  d.setDate(d.getDate() + days);
  return d;
}

function startOfWeek(date) {
  const d = new Date(date);
  d.setDate(d.getDate() - d.getDay());
  d.setHours(0, 0, 0, 0);
  return d;
}
